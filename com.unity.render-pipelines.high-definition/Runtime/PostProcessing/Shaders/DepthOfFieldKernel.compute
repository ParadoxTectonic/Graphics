#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/DepthOfFieldCommon.hlsl"

#pragma only_renderers d3d11 playstation xboxone vulkan metal switch

#pragma kernel KParametricBlurKernel          MAIN=KParametricBlurKernel        GROUP_SIZE=64

// Unused, keeping this just in case
#pragma kernel KParametricFloodfillKernel     MAIN=KParametricFloodfillKernel   GROUP_SIZE=16

// Each uint holds two fp16 (x,y) normalized coordinates
RWStructuredBuffer<uint> _BokehKernel;

CBUFFER_START(cb0)
    float4 _Params1;
    float4 _Params2;
CBUFFER_END

#define SampleCount    _Params1.x
#define NGonFactor     _Params1.y
#define BladeCount     _Params1.z
#define Rotation       _Params1.w
#define Anamorphism    _Params2.x

float2 GetSample(uint i, uint count)
{
    // Fibonacci spiral
    float r = sqrt(float(i + 0.333) / float(count));
    float phi = float(i) * 2.39996323f;  // "golden angle"

    // Transform to rotated ngon
    // "CryEngine 3 Graphics Gems" [Sousa13]
    float n = BladeCount;
    float nt = cos(PI / n);
    float dt = cos(phi - (TWO_PI / n) * floor((n * phi + PI) / TWO_PI));
    r = r * PositivePow(nt / dt, NGonFactor);
    float u = r * cos(phi - Rotation);
    float v = r * sin(phi - Rotation);

    v *= 1.0 + Anamorphism;
    u *= 1.0 - Anamorphism;

    return float2(u, v);
}

[numthreads(GROUP_SIZE, 1, 1)]
void MAIN(uint dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId >= uint(SampleCount * SampleCount))
        return;

    // Grab the sample (range [-1,1])
    float2 smp = GetSample(dispatchThreadId, SampleCount*SampleCount);

    // Pack two fp16 in a single uint, we don't need full fp32 precision
    _BokehKernel[dispatchThreadId] = PackKernelCoord(smp);
}
